#coding:utf-8
"""
首先要知道ISO协议：最开始分为7层（应表会传网数物），后来将 应表会 合在一块叫应用层了。

socket是什么呢？
	socket是应用层与TCP/IP协议族通信的中间软件抽象层，提供了操作tcp/ip协议的接口。我们就可以直接通过socket进行组织数据以符合协议。

基于文件类型的套接字家族：AF_UNIX（AF是address family）
	最开始的计算机是没有网络的，所以只有进程间的通信。Unix一切接文件，就是基于文件系统工作的。进程之间的通信也就是基于文件系统间接完成通信。

基于网络类型的套接字家族：AF_INET
	后来网络出来了。网络间的通信就必须要有一个新的方式来进行不同机器上进程的通信。当然还有很多家族，只不过这应用的最广泛。python也可以支持一些其他家族的套接字。

tcp协议正常的工作过程
三次握手：
	客户端发起连接，发了一个SYN（SEQ=x）报文，进入SYN_SEND状态。
	服务端收到syn包后，回了客户端的SYN(SEQ=y)和ACK(ACK=x+1)报文，进入SYN_RECV状态。（其实这一步本来是2部，但是可以合成一部，因为没有传输的数据在里面）
	客户端收到这两个包之后，回了ACK(ACK=y+1）报文，进入Established状态。连接就算建立起来了。
数据传输：
	客户端开始传输[数据+ack包]给服务端。
	服务端读取后，要返回[内容+ack包]给客户端。
四次挥手：（*断开连接可能由客户端发起，也可能由服务端发起*）
	数据传输完成后，客户端发起断开请求，向服务端发了FIN分节（类似于文件结束符）和ack包。
	服务端返回ack包，此时客户端向服务端连接的那条线断开了。
	服务端再向客户端发起fin包。
	客户端再返回ack包，此时服务端向客户端连接的那条线也断开了。结束。

这些syn、ack、fin这些包再次传输的时候都是经过处理的，不一样的


查看这个端口的服务
netstat -an|grep 端口号
端口状态为listen的话，说明程序在监听状态，等待客户端连接。
端口状态为time_wait状态，说明是这个服务主动发起的断开连接。在生产环境中一般都是服务端发起的断开连接，因为保持连接要消耗计算机资源。
端口状态为fin_wait2状态时，说明是客户端主动发起的断开。
端口状态为establish，则是与客户端建立连接的状态
"""